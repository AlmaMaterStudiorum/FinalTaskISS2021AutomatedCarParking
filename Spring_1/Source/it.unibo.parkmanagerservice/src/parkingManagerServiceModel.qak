/*
 * parkingArea.qak
 * ------------------------------------------------------------------
 * 
 * ASSUMPTIONS:
 *	- INDOOR  : cell (6,0)
 *  - OUTDOOR : cell (6,4)
 *  - One free parking slot : cell(3,2)	SLOTNUM=5
 *  - One client at a time
 *  - No sensors and fan
 *  - Temperature over TMAX (the trolley can be stopped)
 *	- The token corresponds to the parking slot number
 *  - The client who picks up a car waits until the trolley transports his/her car to the OUTDOOR
 *  - The parking manager is already logged in
 */

System parkingmanagerservicesystem


// Context : ctxclientguiparkin
// Entity (GUI) :  clientguiparkin
Request  parkinreq : parkinreq(X)
Reply    informin    : informin(SLOTNUM)

Dispatch carrequest : carrequest(X)
Dispatch carenter : carenter(X)

Dispatch carrequestresponse : carrequestresponse(X)
Dispatch carenterresponse : carenterresponse(X)

Request  carenterreq : carenterreq(SLOTNUM)
Reply    receipt    : receipt(TOKENID)


// Context : ctxclientguiparkout
// Entity (GUI):  clientguiparkout
Request pickup : pickup(TOKENID)
Reply   pickupok    : pickupok(SLOTNUM)


// Context : ctxcommand
// Actor :  statusActor
Request ready : ready(P,D)
Reply   aknready    : aknready(AKN)

// Actor :  plannerActor
Request plan : plan(PLAN)
Reply   aknplan    : aknplan(AKN)

// Actor :  routeActor
Request route : route(ROUTE)
Reply   aknroute    : aknroute(AKN)

// Actor :  driverActor
Request op : op(OP)
Reply   aknop    : aknop(AKN)

// Context : ctxservergui
// Entity (GUI):  ctxservergui
Request commandToSim : commandToSim(X)
Reply   akncommandToSim    : akncommandToSim(AKN)

// Context : ctxsim
// Actor   : simactor
Request simtostatus : simtostatus(X)
Reply   aknsimtostatus    : aknsimtostatus(AKN)

Request simtodriver : simtodriver(X)
Reply   aknsimtodriver    : aknsimtodriver(AKN)

Dispatch simtowenv : simtowenv(X)

// Context : ctxsimgui
// Entity (GUI):  simgui
Request simaction : simaction(X)
Reply   aknsimaction    : aknsimaction(AKN)



Context ctxclientguiparkin ip[host="localhost\\clientguiparkin" port=10100]
Context ctxclientguiparkout ip[host="localhost\\ctxclientguiparkout" port=10200]

Context ctxclientparkin ip[host="localhost" port=10101]
Context ctxclientparkout ip[host="localhost" port=10201]

Context ctxcommand ip[host="localhost" port=10300]

Context ctxservergui ip[host="localhost" port=10400]
Context ctxserver ip[host="localhost" port=10401]

Context ctxsimgui ip[host="localhost" port=10500]
Context ctxsim ip[host="localhost" port=10501]



ExternalQActor clientguiparkin context ctxclientguiparkin 
ExternalQActor clientguiparkout context ctxclientguiparkout 
ExternalQActor servergui context ctxservergui 


QActor clientparkin context ctxclientparkin {
	[# var SLOTNUM = 0 #]
	//-------------------------------------------------------------------------
	State initstate initial {
		println("Enter initstate")

	}
	Goto waitfromclientguistate
	//-------------------------------------------------------------------------
	
	
	
	//-------------------------------------------------------------------------
	State waitfromclientguistate {
		println("Enter waitfromclientguistate")

	}
	Transition t0
	    // Request from ClientGUI 
		whenMsg carrequest -> carrequeststate
	//-------------------------------------------------------------------------
	
	
	
	//-------------------------------------------------------------------------
	State carrequeststate {
		println("Enter carrequeststate")
		
		request statusactor -m parkinreq : parkinreq(X)
	}
	Goto waitforinforminstate
	//-------------------------------------------------------------------------
	
	
	//-------------------------------------------------------------------------
	State waitforinforminstate {
		println("Enter waitforinforminstate")
	}
	Transition t0
		whenReply informin ->  waitforcarenter
	
	//-------------------------------------------------------------------------
	
	//-------------------------------------------------------------------------
	State waitforcarenter {
		println("Enter waitforcarenter")
        
	}
	Transition t0
		whenMsg carenter ->  carenterstate
		
	//-------------------------------------------------------------------------
	
	
	
	//-------------------------------------------------------------------------
	State carenterstate {
		println("Enter carenterstate")
		
		request statusactor -m carenterreq : carenterreq(SLOTNUM)
	}
	Goto waitforreceipt
	//-------------------------------------------------------------------------
	
	
	//-------------------------------------------------------------------------
	State waitforreceipt {
		println("Enter waitforreceipt")
        
	}
	Transition t0
		whenReply receipt ->  receiptstate
		
	//-------------------------------------------------------------------------
	
	
	//-------------------------------------------------------------------------
	State receiptstate {
		println("Enter receiptstate")
		
		forward clientguiparkin -m carenterresponse : carenterresponse(X)
	}
	Goto waitfromclientguistate
	//-------------------------------------------------------------------------
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	State carrequeststate {
		println("clientguiparkin parkinreq")
		updateResource [# "clientguiparkin parkinreq" #]
		
		request statusactor -m parkinreq : parkinreq(X)
	}
	
		State carrequeststate {
		println("clientguiparkin parkinreq")
		updateResource [# "clientguiparkin parkinreq" #]
		
		request statusactor -m parkinreq : parkinreq(X)
	}
	
	// ----------------------------------
	
	
	
	Transition t0
		whenTime 1000 -> retrylater		//The client does not wait forever...
	    whenReply enter -> enterthecar
	
	State enterthecar {
 		onMsg(enter : enter(SLOTNUM)){
			[# SLOTNUM = payloadArg(0).toInt() #]
			
			println("indoorparkingservicegui receives SLOTNUM = $SLOTNUM")
			updateResource [# "indoorparkingservicegui receives SLOTNUM = $SLOTNUM" #]
		}		
	}
	Goto retrylater if [# SLOTNUM == 0 #] else movethecartoindoor
	
	State movethecartoindoor {
		println("indoorparkingservicegui moving the car in the INDOOR and press CARENTER")
		updateResource [# "indoorparkingservicegui oving the car in the INDOOR and press CARENTER" #]
		
		request clientservice -m carenter : carenter($SLOTNUM)		
	}
	Transition t0 
		whenReply receipt -> afterreceipt
	
	//The client leaves
	State afterreceipt {
		println("indoorparkingservicegui leaves")
		updateResource [# "indoorparkingservicegui leaves" #]
	}
	
	//The client leaves, notify it to the clientservice
	State retrylater {
		println("indoorparkingservicegui will retry later")
		updateResource [# "indoorparkingservicegui will retry later" #]
		
		forward clientservice -m goToWork : goToWork(bob)
	}
}

QActor statusactor context ctxcommand {
		State initState initial {
		println("Enter initState")

	}
}

QActor outdoorparkingservicegui context ctxcarparking {
	State s0 initial {
		println("outdoorparkingservicegui STARTS")
		updateResource [# "outdoorparkingservicegui STARTS" #]
	}
	Goto work
	
	State work {
		println("outdoorparkingservicegui waiting for commands ...")
		updateResource [# "outdoorparkingservicegui waiting for commands ..." #]
	}
	Transition t0
		whenMsg doAction -> requestToExit
	
	State requestToExit {
		onMsg(doAction : doAction(TOKENID)) {
			[# var TOKENID = payloadArg(0).toInt() #]
			println("outdoorparkingservicegui requestToExit($TOKENID)")
			updateResource [# "outdoorparkingservicegui requestToExit($TOKENID)" #]
		
			request clientservice -m reqexit : reqexit($TOKENID)	
		}
	}
	Transition t0
	    whenReply exit -> afterreceipt
	
	//The client leaves
	State afterreceipt {
		println("outdoorparkingservicegui leaves")
		updateResource [# "outdoorparkingservicegui leaves" #]
	}
}
 
QActor clientservice context ctxcarparking {
	State s0 initial {
		println("clientservice STARTS")
		updateResource [# "clientservice STARTS" #]
	}
	Goto work
	
	State work {
		println("clientservice waiting ...")
		updateResource [# "clientservice waiting ..." #]
	}
	Transition t0 
		whenRequest reqenter -> handleEnterRequest
		whenRequest reqexit -> handleOutRequest
	
	State handleEnterRequest {
		printCurrentMessage
		println("clientservice reply to reqenter")
		updateResource [# "clientservice reply to reqenter" #]
		
		[# var SLOTNUM = 0 #]
		
		//acceptIN
		//The trolley state can also be retrieved through the COAP protocol using it.unibo.tf21Analisi/resources/utils/CoapObserver.kt
		if [# ParkingAreaKb.indoorfree && !ParkingAreaKb.trolleyStopped #] {
			//Get first free parking spot, or 0
			[# 
				for(i in 0..5) {
					if(ParkingAreaKb.slotStateFree[i] == true) {
						SLOTNUM = i + 1
						break
					}
				}
			#]
			
			if [# SLOTNUM == 0 #] {
				forward clientservice -m goToWork : goToWork(enter($SLOTNUM))
				//backToHome requirement has been incorporated in trolley's idle state
			}
		}
		else {
			//Reply with slotnum=0 to indicates both indoor area and trolley are occupied
			forward clientservice -m goToWork : goToWork(enter($SLOTNUM))
		}
		
		//informIN
		println("clientservice reply enter($SLOTNUM)")
		updateResource [# "clientservice reply enter($SLOTNUM)" #]
			
		replyTo reqenter with enter : enter($SLOTNUM)
	}
	Transition t0
		whenMsg goToWork -> work
		whenRequest carenter -> enterthecar
	
	State enterthecar {
		printCurrentMessage		
		println("parkingclientservice reply to enterthecar")
		updateResource [# "parkingclientservice reply to enterthecar" #]
		
 		onMsg(carenter : carenter(SLOTNUM)) {
			[# 
				var SLOTNUM = payloadArg(0).toInt()
				ParkingAreaKb.slotStateFree[SLOTNUM-1] = false	//Set the slot occupied
			#]
			
			//moveToPark
			forward trolley -m moveToPark : moveToPark($SLOTNUM)
			
			//Reply with the TOKENID
			println("parkingclientservice moves the car to SLOTNUM = $SLOTNUM")
			updateResource [# "parkingclientservice moves the car to SLOTNUM = $SLOTNUM" #]
			replyTo carenter with receipt : receipt($SLOTNUM)
		}		
	}
	Goto work
	
	State handleOutRequest {
		printCurrentMessage
		println("parkingclientservice reply to reqexit")
		updateResource [# "parkingclientservice reply to reqexit" #]
		onMsg(reqexit : reqexit(TOKENID)) {
			//findSlot
			[# var CARSLOTNUM = payloadArg(0).toInt() #]
			
			//Check if the tokenid is valid
			if [# ParkingAreaKb.outdoorfree && !ParkingAreaKb.trolleyStopped && CARSLOTNUM >= 1 && CARSLOTNUM <= 6 && !ParkingAreaKb.slotStateFree[CARSLOTNUM - 1] #] {
				[# ParkingAreaKb.slotStateFree[CARSLOTNUM-1] = true #]	//Set the slot free

				forward trolley -m moveToOut : moveToOut($CARSLOTNUM)	//moveToOut
			}
			else {
				[# CARSLOTNUM = 0 #]	//Error
			}
			
			//Reply with the CARSLOTNUM
			println("parkingmanagerservice moves the car to SLOTNUM = $CARSLOTNUM")
			updateResource [# "parkingmanagerservice moves the car to SLOTNUM = $CARSLOTNUM" #]
			replyTo reqexit with exit : exit($CARSLOTNUM)
		}
	}
	Goto work
}

QActor parkservicestatusgui context ctxcarparking {
	State s0 initial {
		println("parkservicestatusgui STARTS")
		updateResource [# "parkservicestatusgui STARTS" #]
	}
	Goto work
	
	State work {
		println("parkservicestatusgui waiting for commands ...")
		updateResource [# "parkservicestatusgui waiting for commands ..." #]
	}
	Transition t0
		whenMsg doAction -> toggleState
	
	State toggleState {
		println("parkservicestatusgui toggle state")
		updateResource [# "parkservicestatusgui toggle state" #]
		
		forward managerservice -m toggleState : toggleState(X)
	}
	Goto work
}

QActor managerservice context ctxcarparking {
	State s0 initial {
		println("managerservice STARTS")
		updateResource [# "managerservice STARTS" #]
	}
	Goto work
	
	State work {
		println("managerservice waiting ...")
		updateResource [# "managerservice waiting ..." #]
	}
	Transition t0
		whenMsg toggleState -> toggleTrolleyState
	
	State toggleTrolleyState {
		if [# ParkingAreaKb.trolleyStopped #] {
			[# ParkingAreaKb.trolleyStopped = false #]
			
			println("managerservice emit resume")
			updateResource [# "managerservice emit resume" #]
			forward trolley -m  resume : resume(X)
		}
		else {
			[# ParkingAreaKb.trolleyStopped = true #]
			
			println("managerservice emit stop")
			updateResource [# "managerservice emit stop" #]
			forward trolley -m stop : stop(X)
		}
	}
	Goto work
}

QActor trolley context  ctxcarparking{
	State s0 initial {
		println("trolley STARTS")
		updateResource [# "trolley STARTS" #]
	}
	Goto idle
	
	State idle {
		println("trolley IDLE")
		updateResource [# "trolley IDLE" #]
		
		//Moves the trolley to the home position if not there already
	}
	Transition t0
		whenMsg stop -> stopped
		whenMsg moveToPark -> working
		whenMsg moveToOut -> working
	
	State working {
		printCurrentMessage
		println("trolley WORKING")
		updateResource [# "trolley WORKING" #]
		
		delay 1000
		
		onMsg(moveToPark : moveToPark(SLOTNUM)) {
			[# var SLOTNUM = payloadArg(0).toInt() #]
			println("trolley moveToPark($SLOTNUM)")
			updateResource [# "trolley moveToPark($SLOTNUM)" #]
			
			delay 1000
			
			//Move the trolley to the INDOOR area
			
			//Move the trolley to the specific parking slot
		}
		
		onMsg(moveToOut : moveToOut(SLOTNUM)) {
			[# var SLOTNUM = payloadArg(0).toInt() #]
			println("trolley moveToOut($SLOTNUM)")
			updateResource [# "trolley moveToOut($SLOTNUM)" #]
						
			//Move the trolley to the specific parking slot
			
			//Move the trolley to the OUTDOOR area
		}
		
		forward trolley -m goToIdle : goToIdle(X)
	}
	Transition t0
		whenMsg stop -> stopped
		whenMsg goToIdle -> idle
		
	
	State stopped {
		println("trolley STOPPED")
		updateResource [# "trolley STOPPED" #]
	}
	Transition t0
		whenMsg resume -> working
}
 